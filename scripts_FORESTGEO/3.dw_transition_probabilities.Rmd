---
title: "decay probabilities"
author: "abbey yatsko"
date: "4/19/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

#### 1. READ IN DATA ----
```{r}
data <- read.csv("/Users/abbeyyatsko/Desktop/repos/serc_deadwood/data_FORESTGEO/final_data_FORESTGEO/transition_survey_14-21.csv")
```

#### 2. DECAY CLASS PROBABILITY MATRIX FROM DATA (non-annualized) ----
main question: what are the probabilities of transition between the different states (1-3 decay classes) across three time points (2014, 2017, 2021)?

4 code chunks in this section: 
  * 2017-2021 (5 tier)
  * 2017-2021 (3 tier)
  * 2014-2017 (3 tier)
  * 2014-2021 (3 tier)
generating 4 unique probability matrices, which will need to be annualized in the next step

this section is just for transitioning from 2017 - 2021, but using 5 TIERS
```{r}
# create an empty 5x5 matrix
decay.mat <- matrix(0, nrow = 5, ncol = 5)

# instructions for how to fill in the matrix: 2017 is column, 2021 is row
for(i in 1:nrow(data)) {
	decay.mat[data$DC.2021[i], data$DC.2017[i]] <- decay.mat[data$DC.2021[i], data$DC.2017[i]] + 1
}

# decay.mat shows the absolute numbers of pieces that were moving between decay stages from 2017-2021
decay.mat
# sum the columns to see how many 'came out the other end' of the transition
colSums(decay.mat)
# table of data$DC.2017 shows initial inputs from 2017
table(data$DC.2017)
# there will be differences between table(data$DC.2017) and colSums(decay.mat) - this represents pieces that did not survive 

# percent probability of going from a particular decay state in 2017 to the next state in 2021 
decay.prob <- sweep(decay.mat,2,table(data$DC.2017),`/`) # need to be dividing by the table(data$DC.2017) counts rather than colSums(decay.mat)
decay.prob

# to check and make sure that survival is not 100% (which it should not be) - colSums should be < 1.0 
colSums(decay.prob)

# checks out! also makes sense because values get smaller and smaller. 'leakage' at the 1-2 decay stages should be low - this implies that most 1's and 2's are moving through to other decay classes further along, but not disappearing all together. for the 4's and 5's, 'survival' is lower because we expect the probability of 'recapture' to be lower. essentially, pieces at 4/5 are more likely to be moving out of the system, i.e. going undetected in further surveys.
```

this section is just for transitioning from 2017 - 2021, but using 3 TIERS
```{r}
# create an empty 3x3 matrix
decay.mat <- matrix(0, nrow = 3, ncol = 3)

# instructions for how to fill in the matrix: 2017 is column, 2021 is row
for(i in 1:nrow(data)) {
	decay.mat[data$DC.2021_3[i], data$DC.2017_3[i]] <- decay.mat[data$DC.2021_3[i], data$DC.2017_3[i]] + 1
}

# percent probability of going from a particular decay state in 2017 to the next state in 2021 
decay.prob2 <- sweep(decay.mat,2,colSums(decay.mat),`/`)
decay.prob2
```

this section is just for transitioning from 2014 - 2017, but using 3 TIERS
```{r}
# create an empty 3x3 matrix

decay.mat <- matrix(0, nrow = 3, ncol = 3)

# instructions for how to fill in the matrix: 2014 is column, 2017 is row
for(i in 1:nrow(data)) {
	decay.mat[data$DC.2017_3[i], data$DC.2014[i]] <- decay.mat[data$DC.2017_3[i], data$DC.2014[i]] + 1
}

# percent probability of going from a particular decay state in 2014 to the next state in 2017 
decay.prob3 <- sweep(decay.mat,2,colSums(decay.mat),`/`)
decay.prob3

```

this section is just for transitioning from 2014 - 2021, but using 3 TIERS
```{r}
# create an empty 3x3 matrix

decay.mat <- matrix(0, nrow = 3, ncol = 3)

# instructions for how to fill in the matrix: 2014 is column, 2017 is row
for(i in 1:nrow(data)) {
	decay.mat[data$DC.2021_3[i], data$DC.2014[i]] <- decay.mat[data$DC.2021_3[i], data$DC.2014[i]] + 1
}

# percent probability of going from a particular decay state in 2014 to the next state in 2017 
decay.prob4 <- sweep(decay.mat,2,colSums(decay.mat),`/`)
decay.prob4

```

interesting things going on with decay.prob3 and decay.prob4: the probability of a 3 reverting to a 2 from 2014 onward is higher than a 3 staying as a 3. this could be an artifact of converting between decay class scales.

#### 4. BREAKDOWN STATUS PROBABILITY MATRIX FROM DATA ----


```{r}
# split data between snag and downed 
colnames(data)
data %>%
  select("PIECETAG", "STEMTAG", "BDS.2014_new", "BDS.2017_new", "BDS.2021_new") -> bdsdata

# code log/snag elements in bdsdata as 1 = snag, 2 = log 
bdsdata <- bdsdata %>%
    mutate(BDS.2014_new = case_when(
      BDS.2014_new == "snag" ~ "1",
      BDS.2014_new == "log" ~ "2")) %>% 
  mutate(BDS.2017_new = case_when(
    BDS.2017_new == "snag" ~ "1",
    BDS.2017_new == "log" ~ "2")) %>% 
  mutate(BDS.2021_new = case_when(
    BDS.2021_new == "snag" ~ "1",
    BDS.2021_new == "log" ~ "2"))

# change variable type to interger 
bdsdata$BDS.2014_new <- as.integer(bdsdata$BDS.2014_new) 
bdsdata$BDS.2017_new <- as.integer(bdsdata$BDS.2017_new) 
bdsdata$BDS.2021_new <- as.integer(bdsdata$BDS.2021_new) 
str(bdsdata)

# for 2014 - 2017 
# create an empty 2x2 matrix (two options - log or snag)
bds.mat <- matrix(0, nrow = 2, ncol = 2)

# instructions for how to fill in the matrix: 2014 is column, 2017 is row
for(i in 1:nrow(bdsdata)) {
  bds.mat[bdsdata$BDS.2017_new[i], bdsdata$BDS.2014_new[i]] <- bds.mat[bdsdata$BDS.2017_new[i], bdsdata$BDS.2014_new[i]] + 1
}

# percent probability of going from a particular decay state in 2017 to the next state in 2021 
bds.prob <- sweep(bds.mat,2,colSums(bds.mat),`/`)
bds.prob

# for 2017 - 2021 
# create an empty 2x2 matrix (two options - log or snag)
bds.mat <- matrix(0, nrow = 2, ncol = 2)

# instructions for how to fill in the matrix: 2017 is column, 2021 is row
for(i in 1:nrow(bdsdata)) {
  bds.mat[bdsdata$BDS.2021_new[i], bdsdata$BDS.2017_new[i]] <- bds.mat[bdsdata$BDS.2021_new[i], bdsdata$BDS.2017_new[i]] + 1
}

# percent probability of going from a particular decay state in 2017 to the next state in 2021 
bds.prob2 <- sweep(bds.mat,2,colSums(bds.mat),`/`)
bds.prob2

# for 2014 - 2021 
# create an empty 2x2 matrix (two options - log or snag)
bds.mat <- matrix(0, nrow = 2, ncol = 2)

# instructions for how to fill in the matrix: 2014 is column, 2021 is row
for(i in 1:nrow(bdsdata)) {
  bds.mat[bdsdata$BDS.2021_new[i], bdsdata$BDS.2014_new[i]] <- bds.mat[bdsdata$BDS.2021_new[i], bdsdata$BDS.2014_new[i]] + 1
}

# percent probability of going from a particular decay state in 2017 to the next state in 2021 
bds.prob3 <- sweep(bds.mat,2,colSums(bds.mat),`/`)
bds.prob3
```

#### 5. ANNUALIZE DECAY CLASS PROBABILITY MATRIX ----
since multiple years pass between each deadwood survey, the probabilities in the decay transition matrices need to be 'annualized' 

* 2014-2017: 3 years 
* 2017-2021: 4 years 
* 2014-2021: 7 years

the way to do this is (% in matrix)^(1/years passed)

or does it make sense to do proportions? 
(0.5 change) / (3 years) = (? change) / (1 year)

(? change) = (0.5 change) / (3 years)

```{r}
# write annualize function (for different year gap scenarios: 3,4,7)

# for 3 years 
annualize3 <- function(x) {
  x_an <- x^(1/3)
  return(x_an)
}

# for 4 years 
annualize4 <- function(x) {
  x_an <- x^(1/4)
  return(x_an)
}

# for 7 years 
annualize7 <- function(x) {
  x_an <- x^(1/7)
  return(x_an)
}

# 2017 - 2021 (5 tier)
decay.prob
decay.prob_an <- apply(decay.prob, c(1, 2), annualize4)

# 2017 - 2021 (3 tier)
decay.prob2
decay.prob2_an <- apply(decay.prob2, c(1, 2), annualize4)

# 2014 - 2017 (3 tier)
decay.prob3
decay.prob3_an <- apply(decay.prob3, c(1, 2), annualize3)

# 2014 - 2021 (3 tier)
decay.prob4
decay.prob4_an <- apply(decay.prob4, c(1, 2), annualize7)
```

#### 6. CREATE DECAY CLASS TRANSITION SIMULATIONS ----

first start with a simulated matrix example: 
```{r}
# set up an empty matrix
A <- matrix(0, 3, 3)

# populate matrix with different 'decay transition probabilities'
A[1, 1] <- 0.6
A[2, 1] <- 0.3
A[3, 1] <- 0.1
A[1, 2] <- 0.05
A[2, 2] <- 0.6
A[3, 2] <- 0.35
A[1, 3] <- 0.01
A[2, 3] <- 0.1
A[3, 3] <- 0.89

# see what the matrix looks like 
A

# pick a timeframe for the simulation to run over
yrs <- 25

# create a matrix (N_tot) for running the simulation, where the columns are each year of 
# the simulation and the rows are the proportion of pieces in each decay class, by year
N_tot <- matrix(0, ncol = yrs, nrow = 3)

# in the first year, put in 30 pieces of decay class 1 wood into the system 
N_tot[, 1] <- matrix(c(30, 0, 0), ncol = 1)

# start the simulation in the second year. use the inputs from the first year 
# (30 pieces of decay class 1 wood) and run them against the probability matrix 'A'
for(i in 2:yrs) {
	N_tot[, i] <- N_tot[, i - 1] %*% A
}

# look at the transition matrix simulated out to X years 
N_tot 

# display time series matrix simulation (N_tot) as a time series plot
ts.plot(t(N_tot), col = c(1, 2, 3))

# color legend: 
# DC1 = black
# DC2 = red 
# DC3 = green

# play around with different values to see consequences of different decay class pool strengths 
```

next use a calculated matrix from the 2017-2021 decay class transition data:
NOTE this is transitioning *5 TIER* decay classes first, then *3 TIER* second
```{r}
# matrix is held in 'decay prob', using annualized version (decay.prob_an)
decay.prob_an

# timeframe and empty simulation matrix
yrs <- 50
N <- matrix(0, ncol = yrs, nrow = 5)

# insert different starting conditions
# just influx of a bunch of 1s and 2s
N[, 1] <- matrix(c(300, 0, 0, 0, 0), ncol = 1)

# influx for a bunch of different classes across the decay process
#N[, 1] <- matrix(c(300, 500, 550, 400, 200, 0), ncol = 1)

# start the simulation in the second year. use the inputs from the first year 
# (30 pieces of decay class 1 wood) and run them against the probability matrix 'A'
for(i in 2:yrs) {
	N[, i] <- N[, i - 1] %*% decay.prob_an
}

# look at the transition matrix simulated out to X years
N 

# display time series matrix simulation (N_tot) as a time series plot
ts.plot(t(N), col = c("red", "green", "blue", "pink", "purple", "black"))


# second matrix is when everything is converted to a 3 tier scale, here for 2017-2021
decay.prob2_an

# timeframe and empty simulation matrix
yrs <- 5
N <- matrix(0, ncol = yrs, nrow = 3)

# insert different starting conditions
# just influx of a bunch of 1s and 2s
N[, 1] <- matrix(c(20, 0, 0), ncol = 1)

# influx for a bunch of different classes across the decay process
#N[, 1] <- matrix(c(300, 500, 300), ncol = 1)

# start the simulation in the second year. use the inputs from the first year 
# (30 pieces of decay class 1 wood) and run them against the probability matrix 'A'
for(i in 2:yrs) {
	N[, i] <- N[, i - 1] %*% decay.prob2_an
}

# look at the transition matrix simulated out to X years
N 

# display time series matrix simulation (N_tot) as a time series plot
ts.plot(t(N), col = c("red", "green", "blue"))

```

the above examples show how one pulse at the original time affects decay class pools throughout time. 

next goal is to make simulations where repeated influxes are made at each time point

```{r}
# trying to add pulses of DC = 1 each year for the decay.prob3 scenario (2014-2017)
decay.prob3

# start out with 20 DC = 1 
N <- matrix(0, ncol = 1, nrow = 3)
N[, 1] <- matrix(c(50, 0, 0), ncol = 1)
N

# save t0 deadwood sum
t0 <- rowSums(N)

# first year 
N <- (sweep(decay.prob3, MARGIN=2, N, `*`)) 

# add in 10 as the DC = 1 pulse
N[1,1] <- N[1,1] + 10

# save t1 deadwood sum 
t1 <- rowSums(N)
N <- rowSums(N)
N <- as.vector(N)

# second year
N <- (sweep(decay.prob3, MARGIN=2, N, `*`)) 

# add in 10 as the DC = 1 pulse
N[1,1] <- N[1,1] + 10

# save t2 deadwood sum 
t2 <- rowSums(N)
N <- rowSums(N)
as.vector(N)

# third year
N <- (sweep(decay.prob3, MARGIN=2, N, `*`)) 

# add in 10 as the DC = 1 pulse
N[1,1] <- N[1,1] + 10

# save t3 deadwood sum 
t3 <- rowSums(N)
N <- rowSums(N)
N <- as.vector(N)

# fourth year
N <- (sweep(decay.prob3, MARGIN=2, N, `*`)) 

# add in 10 as the DC = 1 pulse
N[1,1] <- N[1,1] + 10

# save t4 deadwood sum 
t4 <- rowSums(N)
N <- rowSums(N)
N <- as.vector(N)

# combine t0 - t4 into a dataframe 
data <- data.frame(t0, t1, t2, t3, t4)
matplot(t(data),type="l")
```

same as above, but use the 5 tiered example from 2017-2021

```{r}
decay.prob

# start out with 20 DC = 1 
N <- matrix(0, ncol = 1, nrow = 5)
N[, 1] <- matrix(c(50, 0, 0, 0, 0), ncol = 1)
N

# save t0 deadwood sum
t0 <- rowSums(N)

# first year 
N <- (sweep(decay.prob, MARGIN=2, N, `*`)) 

# add in 10 as the DC = 1 pulse
N[1,1] <- N[1,1] + 10

# save t1 deadwood sum 
t1 <- rowSums(N)
N <- rowSums(N)
N <- as.vector(N)

# second year
N <- (sweep(decay.prob, MARGIN=2, N, `*`)) 

# add in 10 as the DC = 1 pulse
N[1,1] <- N[1,1] + 10

# save t2 deadwood sum 
t2 <- rowSums(N)
N <- rowSums(N)
as.vector(N)

# third year
N <- (sweep(decay.prob, MARGIN=2, N, `*`)) 

# add in 10 as the DC = 1 pulse
N[1,1] <- N[1,1] + 10

# save t3 deadwood sum 
t3 <- rowSums(N)
N <- rowSums(N)
N <- as.vector(N)

# fourth year
N <- (sweep(decay.prob, MARGIN=2, N, `*`)) 

# add in 10 as the DC = 1 pulse
N[1,1] <- N[1,1] + 10

# save t4 deadwood sum 
t4 <- rowSums(N)
N <- rowSums(N)
N <- as.vector(N)

# combine t0 - t4 into a dataframe 
data <- data.frame(t0, t1, t2, t3, t4)
matplot(t(data),type="l")

```

turn back to a simulated matrix, 'A', and build in new elements (see notes with sean)
```{r}
# matrix, but add confidence intervals for prediction values 
A[1, 1] <- rnorm(1, 0.6, 0.1)
A[2, 1] <- rnorm(1, 0.3, 0.15)
A[3, 1] <- rnorm(1, 0.1, 0.2)
A[1, 2] <- rnorm(1, 0.05, 0.1)
A[2, 2] <- rnorm(1, 0.6, 0.05)
A[3, 2] <- rnorm(1, 0.35, 0.11)
A[1, 3] <- rnorm(1, 0.01, 0.01)
A[2, 3] <- rnorm(1, 0.1, 0.1)
A[3, 3] <- rnorm(1, 0.89, 0.15)
A

# timeframe and populating matrix setup 
yrs <- 50
N_tot <- matrix(0, ncol = yrs, nrow = 3)
N_tot[, 1] <- matrix(c(30, 0, 0), ncol = 1)

for(i in 2:yrs) {
	N_tot[, i] <- N_tot[, i - 1] %*% A
}

# look at the transition matrix simulated out to X years 
N_tot 

# display time series matrix simulation (N_tot) as a time series plot
ts.plot(t(N_tot), col = c("black", "red", "green"))

# use "plot" and "lines" 
# cycle through and plot every line - creates distribution 
# add = true for ts.plot (check)

################################################################################

# UNFINISHED 

# NEXT TRY
# two loops where the first now feeds into the second (old loop)
# in the first loop you are sampling the larger dataset in order to make multiuple 'A' matrices 
#for(j in 1:samp) {  

# then add in the j randomly sampled A matrices into the loop
# for(i in 2:yrs) {
	N[, i, j] <- N_tot[, i - 1] %*% A
#}
#}
	
ts.plot(t(N_tot), col = c(1, 2, 3))
samp <- 1000
N <- array(0, dim = c(3, yrs, samp))

# use 'apply()' to get means and quantiles from the N array.

# hint: lines()
```

What about comparisons of decay class transition matrix between snags and logs? 
```{r}

# create an empty 2x2 matrix
decay.mat <- matrix(0, nrow = 2, ncol = 2)

# instructions for how to fill in the matrix: 2017 is column, 2021 is row
for(i in 1:nrow(data)) {
	decay.mat[data$BDS.2021_new[i], data$BDS.2017_new[i]] <- decay.mat[data$BDS.2021_new[i], data$BDS.2017_new[i]] + 1
}

# percent probability of going from a particular decay state in 2017 to the next state in 2021 
decay.prob1 <- sweep(decay.mat,2,colSums(decay.mat),`/`)
decay.prob1


```
